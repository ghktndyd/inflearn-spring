### 분석 설계시 고려사항

* 실제 현업에서는 정말 웬만해서는 @ManyToMany는 사용하지 않아야 한다.


* 설계 단계에서는 단방향 매핑을 위주로 설계하는 것이 좋다.


* 상태를 가지고 있는 것들은 코드로 관리하는 것도 좋지만 가독성을 위해 Enum으로 관리하는 것도 좋다.


* 테이블명은 order를 잘 사용하지 않는다. 이유는 RDB에서 order가 예약어기 때문에 관례상 orders로 많이 사용한다.


* RDB에서는 FK를 가지고 있는 테이블이 무조건 주인이다.


* 주인이 아닌 테이블은 단순 조회용으로 사용한다.


* **와래 키가 있는 곳을 연관관계의 주인으로 정해라.**
    * 연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제이지 비즈니스상 우위에 있다고 주인으로 정하면 안된다. 예를 들어서 자동차와 바퀴가 있으면, 일대다 관계에서 항상 다쪽에 외래키가 있으므로 외래키가
      있는 바퀴를 연관관계의 주인으로 정하면 된다. 물론 자동차를 연관관계의 주인으로 정하는 것이 불가능한 것은 아니지만, 자동차를 연관관계의 주인으로 정하면 자동차가 관리하지 않는 바퀴 테이블의 외래 키
      값이 업데이트 되므로 관리와 유지보수가 어렵고, 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 있다. 자세한 내용은 JPA 기본편을 참고하자.


* 실무에서는 Getter는 사용하지만 Setter는 필요한 경우에만 사용


* 내장타입을 할 때는 타입에는 @Embeddable을 붙이고 받는 애는 @Embedded를 붙인다.


* 하나의 멤버는 N개의 주문을 발생 시킬 수 있다. Member 입장에서 봤을 때 멤버는 여러 주문을 갖고 있다.  
  즉 @OneToMany이다. (하나의 멤버가 여러 주문)


* 주문 엔티티는 반대이다.


* @ManyToOne은 기본적으로 @JoinColumn(name = "One 엔티티의 식별자")를 같이 써줘야 한다.


* 멤버-주문의 경우 연관관계의 주인은 주문이다. 왜냐하면 연관관계의 주인을 설정할 때는 FK를 갖고 있는 엔티티를 주인으로 설정한다.


* @OneToMany는 @OneToMany(mappedBy = "주인 엔티티")를 입력해주어야 한다.


* @Inheritance(strategy = InheritanceType.SINGLE_TABLE)는 싱글테이블 전략이다. 만약에 이 어노테이션이 붙어있는 클래스를 상속 받는 클래스가 있다면 해당 클래스를 테이블의 컬럼으로 받게 된다.


* @DiscriminatorColumn(name = "dtype")는 싱글테이블 전략에서 Inheritance와 같이 쓰이는데 name명으로 컬럼(dtype)이 추가되고 상속받는 클래스의 붙어있는 `@DiscriminaotorValue("값")`의 값이 해당 컬럼의 값으로 들어간다.


* @Enumerated(EnumType.STRING)는 무조건 STRING으로 해야 한다.


* 1:1 관계에서는 액세스를 많이 하는 엔티티에 주인을 주는 것이 좋다.


* FK를 사용하는 것과 사용하지 않는 것은 고민해볼 필요가 있다.


* 이론적으로 엔티티가 Getter, Setter를 모두 제공하지 않고 꼭 필요할 때마다 별도의 메서드를 제공하는 것이 가장 이상적이다.


* 하지만 Getter는 아무리 호출한다고 해서 오류가 발생하진 않지만 Setter는 데이터가 변하기 때문에 Setter를 호출하는 것은 조심해야 한다.
 

* 만약에 변경점이 생긴다면 별도의 메서드로 하는 게 좋다.


* 값 타입은 생성할 때 값이 등록되면 그게 바뀌어선 안 된다. 값타입이란 @Embeddable이 붙은 엔티티

