* #### 준영속 엔티티란?

> 영속성 컨텍스트가 더는 관리하지 않는 엔티티

예제 코드에서는 `itemService.saveItem(book)`에서 수정을 시도하는 Book 객체다.

Book 객체는 이미 DB에 한 번 저장되어서 식별자가 존재한다. 이렇게 임의로 만들어낸 엔티티도
기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있다.

* #### 준영속 엔티티를 수정하는 2가지 방법

> 1. 변경 감지 기능 사용
> 2. 병합(Merge) 사용

* #### 병합 동작 방식

1. `merge()`를 실행한다.
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다.

   2-1. 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차 캐시에 저장한다.

3. 조회한 영속 엔티티( `mergeMember` )에 `member` 엔티티의 값을 채워 넣는다. (member 엔티티의 모든 값을
   mergeMember에 밀어 넣는다. 이때 mergeMember의 “회원1”이라는 이름이 “회원명변경”으로 바뀐다.)
4. 영속 상태인 mergeMember를 반환한다.


* 병합 주의점

변경 감지 기능을 사용하면 원하는 속성만 변경 가능하지만 병합은 모든 속성이 변경된다.
만약 병합될 값이 없다면 `null`이 들어간다.

> 결론은 `merge()`는 가급적으로 사용하지 않는다.
>
> 정말 웬만해서는 **변경 감지로 업데이트**를 하는 것이 이상적이다.

* 추가

업데이트는 예제 코드처럼 단발성 코드로 작성하는 것은 좋은 방법은 아니다.
즉, setter를 사용하는 것을 삼가고, 의미있는 명을 갖고 있는 메서드를 만들어서 사용하는 것이 권장된다.

* 가장 좋은 해결 방법

    * **엔티티를 변경할 때는 항상 변경 감지를 사용하세요**
    * 컨트롤러에서 어설프게 엔티티를 생성하지 마세요.
    * 트랜잭션이 있는 서비스 계층에 식별자( `id` )와 변경할 데이터를 명확하게 전달하세요.(파라미터 or dto) 
    * 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접
      변경하세요. 
    * 트랜잭션 커밋 시점에 변경 감지가 실행됩니다.